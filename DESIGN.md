# Quantstrat Strategy Modifier Architecture - Design Document

## 1. Executive Summary

This document describes a modular architecture for trading strategy backtesting that separates concerns between:
- **Strategy Logic**: Signal generation and position decisions
- **Strategy Modifiers**: Composable transformations of strategy behavior
- **Backtester**: Exposure management and PnL calculation

The design uses a modifier (decorator) pattern to enable flexible, testable, and composable enhancements to strategies without modifying core backtesting infrastructure.

---

## 2. Core Principles

### 2.1 Separation of Concerns

```
Signal Generation → Position Targeting → Execution → Exposure Management → PnL
   (Strategy)         (Strategy)        (Modifiers)    (Backtester)      (Backtester)
```

**Strategy Responsibilities:**
- Generate real-valued signals from price data
- Convert signals to target positions (pre-exposure adjustment)
- Return DataFrame with OHLCV, signals, and target positions

**Modifier Responsibilities:**
- Transform execution timing (when trades occur)
- Adjust position sizing
- Filter signals
- Add risk management rules
- Implement order types

**Backtester Responsibilities:**
- Apply exposure multipliers to target positions
- Calculate accurate PnL accounting for execution timing
- Compute slippage and transaction costs
- Generate performance statistics

### 2.2 Design Goals

1. **Modularity**: Each component has a single, well-defined responsibility
2. **Composability**: Stack multiple modifiers without conflicts
3. **Extensibility**: Add new modifiers without changing backtester
4. **Testability**: Test each modifier in isolation
5. **Clarity**: Explicit column naming eliminates ambiguity

---

## 3. Data Flow & Column Schema

### 3.1 DataFrame Columns

#### Core Columns (Required)
Generated by strategy's `generate_signals()` method:

| Column | Type | Description | Set By |
|--------|------|-------------|--------|
| `Open` | float | Opening price | Price data |
| `High` | float | High price | Price data |
| `Low` | float | Low price | Price data |
| `Close` | float | Closing price | Price data |
| `Volume` | float | Trading volume | Price data |
| `Volatility` | float | Rolling volatility (%) | BaseStrategy |
| `Signal` | float | Real-valued signal strength | Strategy |
| `Target_Position` | float | Desired position (units), set only on signal days | Strategy |
| `Position_At_Close` | int/float | Actual position held at day's close | Strategy/Modifiers |

#### Execution Metadata (Optional)
Set by execution timing modifiers:

| Column | Type | Values | Description |
|--------|------|--------|-------------|
| `Entry_Time` | str | `'close'`, `'next_open'`, `'next_close'`, `'vwap'`, etc. | When entry executes (set on signal day) |
| `Entry_Price` | float | Price value | Actual execution price for entry |
| `Entry_Type` | str | `'market'`, `'limit'`, `'stop'` | Order type for entry |
| `Exit_Time` | str | `'close'`, `'next_open'`, etc. | When exit executes |
| `Exit_Price` | float | Price value | Actual execution price for exit |
| `Exit_Type` | str | `'market'`, `'limit'`, `'stop'` | Order type for exit |

#### Exposure & Shares (Computed by Backtester)

| Column | Type | Description |
|--------|------|-------------|
| `Exposure_Mult` | float | Exposure multiplier at today's close |
| `Shares_Target` | float | Target shares at today's close = `Position_At_Close × Exposure_Mult` |
| `Shares_At_Close` | float | Actual shares held at today's close (after execution) |
| `Shares_Held_At_Open` | float | Shares held at today's open = `Shares_At_Close.shift(1)` |

#### PnL Columns (Computed by Backtester)

| Column | Type | Description |
|--------|------|-------------|
| `Price_Change` | float | Effective price change for PnL (adjusted for timing) |
| `Unslipped_PnL` | float | PnL before slippage = `Shares_Held_At_Open × Price_Change` |
| `Slippage` | float | Transaction costs in dollars |
| `Slipped_PnL` | float | PnL after slippage = `Unslipped_PnL - Slippage` |

#### Event Detection (Computed)

| Column | Type | Description |
|--------|------|-------------|
| `Is_Signal_Day` | bool | `Target_Position.notna()` |
| `Is_Entry` | bool | Position changes from 0 to non-zero |
| `Is_Exit` | bool | Position changes from non-zero to 0 |

### 3.2 Naming Conventions

**Position vs Shares:**
- `Position_*`: Pre-multiplier values (strategy layer, in "units")
- `Shares_*`: Post-multiplier values (execution layer, actual shares traded)

**Temporal Clarity:**
- `*_At_Close`: Value at close of current day
- `*_At_Prior_Close`: Value at close of previous day (= `*.shift(1)`)
- `*_At_Open`: Value at open of current day
- `*_Held_At_Open`: Shares carried into current day (from prior close)

**Target vs Actual:**
- `Target_Position`: What strategy wants (set only on signal days)
- `Position_At_Close`: What actually happens (every day)

### 3.3 Sample Week-Long DataFrame

```
Scenario: DMA strategy with EnterAtNextOpen modifier
Entry signal on Wed, exit signal on Fri
Vol multiplier changes throughout week

Date    | Open  | Close | Signal | Target_Position | Position_At_Close | Entry_Time  | Entry_Price | Exposure_Mult | Shares_Target | Shares_At_Close | Shares_Held_At_Open | Price_Change | Unslipped_PnL | Slippage
--------|-------|-------|--------|-----------------|-------------------|-------------|-------------|---------------|---------------|-----------------|---------------------|--------------|---------------|----------
Mon 1/1 | 100.0 | 102.0 | 0.0    | NaN             | 0                 | NaN         | NaN         | 2.0           | 0.0           | 0.0             | 0.0                 | 2.0          | 0.0           | 0.0
Tue 1/2 | 101.0 | 103.0 | 0.0    | NaN             | 0                 | NaN         | NaN         | 2.1           | 0.0           | 0.0             | 0.0                 | 1.0          | 0.0           | 0.0
Wed 1/3 | 104.0 | 105.0 | 0.8    | 1               | 0                 | 'next_open' | 104.0       | 2.0           | 0.0           | 0.0             | 0.0                 | 2.0          | 0.0           | 0.0
Thu 1/4 | 106.0 | 107.0 | 1.0    | NaN             | 1                 | NaN         | NaN         | 2.2           | 2.2           | 2.2             | 2.0                 | 1.0          | 2.0           | 1.071
Fri 1/5 | 108.0 | 109.0 | -0.3   | 0               | 1                 | NaN         | NaN         | 2.3           | 2.3           | 2.3             | 2.2                 | 2.0          | 4.4           | 0.0055
Sat 1/6 | 110.0 | 111.0 | 0.0    | NaN             | 0                 | NaN         | NaN         | 2.4           | 0.0           | 0.0             | 2.3                 | 2.0          | 4.6           | 2.51
```

**Key Points:**
- Wed: Signal generated, Target_Position=1, but Position_At_Close=0 (entry delayed)
- Thu: Position_At_Close=1 (entry executed at open), Shares_Held_At_Open=2.0 (using Wed's multiplier)
- Thu Slippage: Entry trade (2.0@106) + Exposure adjustment (0.2@107) = 1.06 + 0.011 = 1.071
- Fri: Exposure adjustment only (0.1 shares@109) = 0.0055

---

## 4. Strategy Layer

### 4.1 BaseStrategy Contract

```python
class BaseStrategy(ABC):
    """
    Abstract base class for trading strategies.

    Responsibilities:
    - Fetch price data
    - Calculate volatility
    - Generate signals
    - Convert signals to target positions
    """

    def __init__(self, volatility_function=None, **strategy_params):
        """
        Args:
            volatility_function: Callable to compute rolling volatility
            **strategy_params: Strategy-specific parameters
        """
        self.volatility_function = volatility_function or partial(simple_vol, N=20)
        self.strategy_params = strategy_params
        self.df = None

    def __call__(self, symbol, start_date, end_date):
        """
        Run strategy for given symbol and date range.

        Returns:
            pd.DataFrame with required columns
        """
        # 1. Fetch prices
        self.prices = self._fetch_prices(symbol, start_date, end_date)

        # 2. Calculate volatility
        self.prices['Volatility'] = self.volatility_function(self.prices)

        # 3. Generate signals and positions
        self.df = self.generate_signals(self.prices)

        # 4. Initialize execution metadata (defaults)
        self.df['Entry_Time'] = np.nan
        self.df['Entry_Price'] = np.nan
        self.df['Exit_Time'] = np.nan
        self.df['Exit_Price'] = np.nan

        return self.df

    @abstractmethod
    def generate_signals(self, prices):
        """
        Strategy-specific logic to generate signals and positions.

        Args:
            prices: DataFrame with OHLCV and Volatility

        Returns:
            DataFrame with columns:
                - All OHLCV columns
                - Volatility
                - Signal: Real-valued signal strength
                - Target_Position: Set only on days when position decision is made
                - Position_At_Close: Actual position at close (default: same as Target_Position)

        Example:
            df = prices.copy()
            df['MA50'] = df['Close'].rolling(50).mean()

            # Real-valued signal
            df['Signal'] = (df['Close'] - df['MA50']) / df['MA50']

            # Discrete positions (set only on signal days)
            df['Target_Position'] = np.nan
            df.loc[df['Signal'] > 0, 'Target_Position'] = 1
            df.loc[df['Signal'] < 0, 'Target_Position'] = 0

            # Default: position equals target (forward-filled)
            df['Position_At_Close'] = df['Target_Position'].fillna(method='ffill').fillna(0)

            return df
        """
        raise NotImplementedError

    # Convenience methods for fluent API
    def enter_at_next_open(self):
        """Fluent API: wrap with EnterAtNextOpen modifier"""
        return EnterAtNextOpen(self)

    def enter_at_next_close(self):
        return EnterAtNextClose(self)

    def exit_at_next_open(self):
        return ExitAtNextOpen(self)

    def scale_position(self, factor):
        return ScalePosition(self, factor)

    def cap_position(self, max_position):
        return CapPosition(self, max_position)

    def with_stop_loss(self, pct):
        return StopLoss(self, pct)

    def only_on_days(self, days):
        return TradeOnlyOnDays(self, days)
```

### 4.2 Strategy Example

```python
class DMA(BaseStrategy):
    """Dual Moving Average strategy"""

    def __init__(self, lookback, K, **kwargs):
        super().__init__(**kwargs)
        self.lookback = lookback
        self.K = K

    def generate_signals(self, prices):
        df = prices.copy()

        # Calculate indicators
        df['MA'] = df['Close'].rolling(self.lookback).mean()
        df['Std'] = df['Close'].rolling(self.lookback).std()

        # Real-valued signal
        df['Signal'] = (df['Close'] - df['MA']) / df['Std']

        # Generate target positions (only on signal days)
        df['Target_Position'] = np.nan
        df.loc[df['Signal'] > self.K, 'Target_Position'] = 1  # Long
        df.loc[df['Signal'] < -self.K, 'Target_Position'] = 0  # Flat

        # Default execution: position at close equals target
        df['Position_At_Close'] = df['Target_Position'].fillna(method='ffill').fillna(0)

        return df.loc[self.start_date:self.end_date]
```

---

## 5. Strategy Modifier Layer

### 5.1 Modifier Base Class

```python
class StrategyModifier(ABC):
    """
    Base class for composable strategy modifiers.

    Modifiers transform strategy behavior by modifying the DataFrame
    returned by the strategy. Common modification types:
    - Execution timing (when trades occur)
    - Position sizing (scale, cap, floor)
    - Signal filtering (trade only on certain conditions)
    - Risk management (stops, limits)
    - Order types (market, limit, stop)
    """

    def __init__(self, strategy):
        """
        Wrap a strategy or another modifier.

        Args:
            strategy: BaseStrategy or StrategyModifier instance
        """
        self.strategy = strategy

    def __call__(self, symbol, start_date, end_date):
        """
        Execute wrapped strategy and apply transformation.

        Returns:
            pd.DataFrame (same as strategy)
        """
        # Run underlying strategy
        self.strategy(symbol, start_date, end_date)

        # Apply transformation
        if self.strategy.df is not None:
            self.transform(self.strategy.df)

        return self.strategy.df

    @abstractmethod
    def transform(self, df):
        """
        Transform the strategy DataFrame.

        Can modify:
        - Position_At_Close
        - Entry_Time, Entry_Price, Entry_Type
        - Exit_Time, Exit_Price, Exit_Type
        - Add new columns
        - Set df.attrs metadata

        Args:
            df: Strategy DataFrame (modified in-place)
        """
        raise NotImplementedError

    def __getattr__(self, name):
        """Delegate attribute access to wrapped strategy"""
        return getattr(self.strategy, name)
```

### 5.2 Modifier Categories

#### 5.2.1 Execution Timing Modifiers

**EnterAtNextOpen**
```python
class EnterAtNextOpen(StrategyModifier):
    """
    Modify entry execution from signal close to next day's open.

    Timeline:
    - Day T close: Signal generated, Target_Position set
    - Day T+1 open: Position entered
    - Day T+1 close: First PnL captured
    """

    def transform(self, df):
        # Detect signal days where entry occurs
        is_signal_day = df['Target_Position'].notna()
        will_enter = is_signal_day & (df['Target_Position'] > 0)

        # Set entry metadata on signal day
        df.loc[will_enter, 'Entry_Time'] = 'next_open'
        df.loc[will_enter, 'Entry_Price'] = df.loc[will_enter, 'Open'].shift(-1)

        # Delay position establishment by one day
        new_position = df['Target_Position'].shift(1).fillna(method='ffill').fillna(0)
        df['Position_At_Close'] = new_position

        # Mark for backtester
        df.attrs['has_next_open_entries'] = True
```

**EnterAtNextClose**
```python
class EnterAtNextClose(StrategyModifier):
    """
    Delay entry by one full day (T+1 close instead of T close).

    Timeline:
    - Day T close: Signal generated
    - Day T+1 close: Position entered
    - Day T+2 close: First PnL captured (lag=1)
    """

    def transform(self, df):
        is_signal_day = df['Target_Position'].notna()
        will_enter = is_signal_day & (df['Target_Position'] > 0)

        df.loc[will_enter, 'Entry_Time'] = 'next_close'
        df.loc[will_enter, 'Entry_Price'] = df.loc[will_enter, 'Close'].shift(-1)

        # Delay position by one day
        new_position = df['Target_Position'].shift(1).fillna(method='ffill').fillna(0)
        df['Position_At_Close'] = new_position

        df.attrs['has_next_close_entries'] = True
```

**ExitAtNextOpen**
```python
class ExitAtNextOpen(StrategyModifier):
    """Exit positions at next day's open instead of close."""

    def transform(self, df):
        is_signal_day = df['Target_Position'].notna()
        will_exit = is_signal_day & (df['Target_Position'] == 0)

        df.loc[will_exit, 'Exit_Time'] = 'next_open'
        df.loc[will_exit, 'Exit_Price'] = df.loc[will_exit, 'Open'].shift(-1)

        df.attrs['has_next_open_exits'] = True
```

**EnterAtVWAP**
```python
class EnterAtVWAP(StrategyModifier):
    """Execute entries at VWAP price (requires VWAP in price data)."""

    def transform(self, df):
        if 'VWAP' not in df.columns:
            raise ValueError("VWAP column required for EnterAtVWAP modifier")

        is_signal_day = df['Target_Position'].notna()
        will_enter = is_signal_day & (df['Target_Position'] > 0)

        df.loc[will_enter, 'Entry_Time'] = 'vwap'
        df.loc[will_enter, 'Entry_Price'] = df.loc[will_enter, 'VWAP']

        df.attrs['custom_execution'] = 'vwap'
```

#### 5.2.2 Position Sizing Modifiers

```python
class ScalePosition(StrategyModifier):
    """Scale all positions by constant factor"""

    def __init__(self, strategy, scale_factor):
        super().__init__(strategy)
        self.scale_factor = scale_factor

    def transform(self, df):
        df['Target_Position'] *= self.scale_factor
        df['Position_At_Close'] *= self.scale_factor


class CapPosition(StrategyModifier):
    """Cap maximum position size"""

    def __init__(self, strategy, max_position):
        super().__init__(strategy)
        self.max_position = max_position

    def transform(self, df):
        df['Target_Position'] = df['Target_Position'].clip(-self.max_position, self.max_position)
        df['Position_At_Close'] = df['Position_At_Close'].clip(-self.max_position, self.max_position)
```

#### 5.2.3 Signal Filtering Modifiers

```python
class TradeOnlyOnDays(StrategyModifier):
    """Only allow entries on specific days of week"""

    def __init__(self, strategy, days=['Monday', 'Wednesday']):
        super().__init__(strategy)
        self.days = days

    def transform(self, df):
        allowed_days = df.index.day_name().isin(self.days)

        # Block new entries on non-allowed days
        position_at_prior_close_was_zero = df['Position_At_Close'].shift(1).fillna(0) == 0
        position_at_current_close_is_nonzero = df['Position_At_Close'] > 0
        is_new_entry = position_at_prior_close_was_zero & position_at_current_close_is_nonzero

        blocked_entries = is_new_entry & ~allowed_days
        df.loc[blocked_entries, 'Target_Position'] = 0
        df.loc[blocked_entries, 'Position_At_Close'] = 0


class MinimumSignalStrength(StrategyModifier):
    """Only trade if signal exceeds threshold"""

    def __init__(self, strategy, threshold):
        super().__init__(strategy)
        self.threshold = threshold

    def transform(self, df):
        weak_signal = df['Signal'].abs() < self.threshold

        position_at_prior_close_was_zero = df['Position_At_Close'].shift(1).fillna(0) == 0
        position_at_current_close_is_nonzero = df['Target_Position'] > 0
        is_new_entry = position_at_prior_close_was_zero & position_at_current_close_is_nonzero

        # Block entries on weak signals
        blocked = is_new_entry & weak_signal
        df.loc[blocked, 'Target_Position'] = 0
        df.loc[blocked, 'Position_At_Close'] = 0
```

#### 5.2.4 Risk Management Modifiers

```python
class StopLoss(StrategyModifier):
    """Add stop-loss exits"""

    def __init__(self, strategy, stop_pct):
        super().__init__(strategy)
        self.stop_pct = stop_pct

    def transform(self, df):
        entry_price = np.nan
        stop_triggered = []

        for idx in df.index:
            pos = df.loc[idx, 'Position_At_Close']
            pos_prior = df['Position_At_Close'].shift(1).loc[idx] if idx != df.index[0] else 0

            # Record entry price
            if pos > 0 and pos_prior == 0:
                entry_price = df.loc[idx, 'Close']

            # Check stop
            if pos > 0 and not np.isnan(entry_price):
                loss_pct = (df.loc[idx, 'Close'] - entry_price) / entry_price * 100
                if loss_pct < -self.stop_pct:
                    stop_triggered.append(idx)
                    entry_price = np.nan

        # Force exit on stop days
        df.loc[stop_triggered, 'Position_At_Close'] = 0
        df.loc[stop_triggered, 'Exit_Time'] = 'close'
        df.attrs['has_stop_loss'] = True
```

#### 5.2.5 Order Type Modifiers

```python
class LimitOrder(StrategyModifier):
    """Enter only if price improves by limit_pct"""

    def __init__(self, strategy, limit_pct):
        super().__init__(strategy)
        self.limit_pct = limit_pct

    def transform(self, df):
        is_signal_day = df['Target_Position'].notna()
        will_enter = is_signal_day & (df['Target_Position'] > 0)

        # Set limit price
        df['Limit_Price'] = np.nan
        df.loc[will_enter, 'Limit_Price'] = df.loc[will_enter, 'Close'] * (1 - self.limit_pct / 100)

        df.loc[will_enter, 'Entry_Type'] = 'limit'
        df.attrs['has_limit_orders'] = True
```

---

## 6. Signals Layer

### 6.1 Overview

The signals layer provides technical indicators and signal generation functions. Signals are used by strategies to make trading decisions. All indicators use a factory pattern for easy parameterization.

### 6.2 Indicator Factory Pattern

```python
def SMA(N):
    """Simple Moving Average indicator factory"""
    def compute_sma(symbol, series):
        return series.rolling(window=N).mean()

    # Add metadata
    compute_sma.__name__ = f'SMA_{N}'
    compute_sma.period = N
    compute_sma.indicator_type = 'SMA'

    return compute_sma
```

**Key Features:**
- **Factory Pattern**: `SMA(200)` creates a 200-day SMA calculator
- **Metadata**: Each indicator carries its period and type
- **Composability**: Indicators can be combined in strategies

### 6.3 Available Indicators

#### Simple Moving Average (SMA)
```python
from signals.technical import SMA

# Create indicator
sma_200 = SMA(200)

# Use in strategy
df['MA_200'] = sma_200('AAPL', df['Close'])

# Or inline
df['MA_50'] = SMA(50)('AAPL', df['Close'])
```

**Formula:** Average of last N prices

**Use Cases:**
- Trend identification
- Support/resistance levels
- Crossover strategies

#### Exponential Moving Average (EMA)
```python
from signals.technical import EMA

ema_20 = EMA(20)
df['EMA_20'] = ema_20('AAPL', df['Close'])
```

**Formula:** Weighted average giving more weight to recent prices

**Use Cases:**
- Faster response to price changes than SMA
- Short-term trend following
- EMA crossovers

#### Relative Strength Index (RSI)
```python
from signals.technical import RSI

rsi_14 = RSI(14)
df['RSI'] = rsi_14('AAPL', df['Close'])
```

**Formula:** Momentum oscillator (0-100)

**Use Cases:**
- Overbought/oversold detection (>70 overbought, <30 oversold)
- Divergence analysis
- Mean reversion strategies

### 6.4 Custom Indicators

Users can create custom indicators following the same pattern:

```python
def CustomIndicator(param1, param2):
    """Custom indicator factory"""

    def compute_indicator(symbol, series):
        # Custom calculation logic
        result = ...  # your calculation here
        return result

    # Add metadata
    compute_indicator.__name__ = f'Custom_{param1}_{param2}'
    compute_indicator.param1 = param1
    compute_indicator.param2 = param2
    compute_indicator.indicator_type = 'Custom'

    return compute_indicator
```

### 6.5 Signal Generation in Strategies

Strategies use indicators to generate signals:

```python
class MovingAverageCrossover(BaseStrategy):
    def __init__(self, short_period, long_period, **kwargs):
        super().__init__(**kwargs)
        self.short_period = short_period
        self.long_period = long_period

    def generate_signals(self, prices):
        df = prices.copy()

        # Use signal indicators
        sma_short = SMA(self.short_period)
        sma_long = SMA(self.long_period)

        df['MA_Short'] = sma_short('symbol', df['Close'])
        df['MA_Long'] = sma_long('symbol', df['Close'])

        # Generate real-valued signal
        df['Signal'] = (df['MA_Short'] - df['MA_Long']) / df['MA_Long']

        # Convert to positions
        df['Target_Position'] = np.nan
        df.loc[df['Signal'] > 0, 'Target_Position'] = 1
        df.loc[df['Signal'] < 0, 'Target_Position'] = -1

        df['Position_At_Close'] = df['Target_Position'].fillna(method='ffill').fillna(0)

        return df
```

---

## 7. Exposure Management Layer

### 7.1 Overview

Exposure managers control position sizing by computing a multiplier that converts strategy positions (typically -1, 0, 1) into actual shares to trade. This layer is independent of strategy logic and handles risk management through position sizing.

**Core Concept:**
```
Actual Shares = Position_At_Close × Exposure_Multiplier
```

### 7.2 ExposureManager Base Class

```python
class ExposureManager(ABC):
    """
    Abstract base class for exposure management.

    Computes a multiplier series from price data that determines
    actual position sizes.
    """

    @abstractmethod
    def __call__(self, prices):
        """
        Calculate exposure multiplier from price data.

        Args:
            prices: DataFrame with OHLCV and Volatility

        Returns:
            pd.Series: Multiplier series (same index as prices)
        """
        pass

    def periodic(self, frequency="daily", when="end", day=None):
        """
        Wrap with periodic updates (monthly, weekly, etc.)

        Returns:
            Periodic: Wrapped exposure manager
        """
        return periodic(self, frequency=frequency, when=when, day=day)
```

### 7.3 VolatilityTargetExposure

Sizes positions to maintain constant dollar volatility.

```python
class VolatilityTargetExposure(ExposureManager):
    """
    Size positions for constant dollar volatility.

    Formula:
        multiplier = total_dollar_size / dollar_volatility
        dollar_volatility = (volatility / 100) × price

    Effect:
        - More shares when volatility is low
        - Fewer shares when volatility is high
        - Approximately constant risk exposure
    """

    def __init__(self, total_dollar_size, volatility_function=None):
        self.total_dollar_size = total_dollar_size
        self.volatility_function = volatility_function or partial(simple_vol, N=20)

    def __call__(self, prices):
        price_series = prices['Close']
        volatility = self.volatility_function(prices)

        # Calculate dollar volatility
        dollar_volatility = (volatility / 100) * price_series

        # Calculate multiplier
        multiplier = self.total_dollar_size / dollar_volatility

        return multiplier.fillna(0)
```

**Example:**
```python
from libs.exposure_management import VolatilityTargetExposure
from functools import partial
from libs.volatility import simple_vol

# Target $100k dollar volatility
exp_mgr = VolatilityTargetExposure(
    total_dollar_size=100000,
    volatility_function=partial(simple_vol, N=20)
)

# Use in backtester
backtester = Backtester(strategy, exposure_manager=exp_mgr)
```

**When to Use:**
- Want consistent risk exposure across different volatility regimes
- Prefer larger positions in stable markets, smaller in volatile markets
- Risk management based on volatility

### 7.4 ConstantDollarExposure

Sizes positions to maintain constant dollar exposure regardless of volatility.

```python
class ConstantDollarExposure(ExposureManager):
    """
    Size positions for constant dollar exposure.

    Formula:
        multiplier = target_dollar_exposure / price

    Effect:
        - More shares when price is low
        - Fewer shares when price is high
        - Approximately constant dollar value
    """

    def __init__(self, target_dollar_exposure):
        self.target_dollar_exposure = target_dollar_exposure

    def __call__(self, prices):
        price_series = prices['Close']

        # Calculate multiplier
        multiplier = self.target_dollar_exposure / price_series

        return multiplier.fillna(0)
```

**Example:**
```python
from libs.exposure_management import ConstantDollarExposure

# Always hold ~$100k worth of stock
exp_mgr = ConstantDollarExposure(target_dollar_exposure=100000)

backtester = Backtester(strategy, exposure_manager=exp_mgr)
```

**When to Use:**
- Want consistent dollar exposure regardless of price or volatility
- Simpler position sizing (similar to fixed dollar allocation)
- Less sensitive to volatility changes

### 7.5 Periodic Rebalancing

Both exposure managers support periodic rebalancing to reduce turnover:

```python
# Monthly rebalancing (update multiplier at start of month)
exp_mgr = VolatilityTargetExposure(100000).periodic(
    frequency="monthly",
    when="start"
)

# Weekly rebalancing (update on Mondays)
exp_mgr = ConstantDollarExposure(100000).periodic(
    frequency="weekly",
    day="monday"
)

# Daily rebalancing (default)
exp_mgr = VolatilityTargetExposure(100000).periodic(
    frequency="daily"
)
```

**Rebalancing Options:**
- **frequency**: `"daily"`, `"weekly"`, `"monthly"`
- **when**: `"start"` or `"end"` of period
- **day**: Day of week for weekly rebalancing (e.g., `"monday"`, `"friday"`)

### 7.6 Exposure Manager Comparison

| Feature | VolatilityTargetExposure | ConstantDollarExposure |
|---------|--------------------------|------------------------|
| **Position Sizing** | Based on volatility | Based on price |
| **Risk Management** | Constant dollar volatility | Constant dollar value |
| **Turnover** | Higher (reacts to vol changes) | Lower (only reacts to price) |
| **Volatility Regimes** | Adapts to vol changes | Ignores volatility |
| **Best For** | Risk-based sizing | Simple dollar allocation |

**Example Comparison:**
```python
# Same strategy, different exposure managers
strategy = DMA(lookback=50, K=2)

# Vol-targeted
vol_exp = VolatilityTargetExposure(100000)
bt1 = Backtester(strategy, exposure_manager=vol_exp)
bt1('AAPL', '2024-01-01', '2024-12-31', slippage_bps=5)

# Constant dollar
const_exp = ConstantDollarExposure(100000)
bt2 = Backtester(strategy, exposure_manager=const_exp)
bt2('AAPL', '2024-01-01', '2024-12-31', slippage_bps=5)

# Compare results
print(f"Vol Target Sharpe: {bt1.slipped_performance['sharpe']:.3f}")
print(f"Const Dollar Sharpe: {bt2.slipped_performance['sharpe']:.3f}")
```

### 7.7 Custom Exposure Managers

Users can create custom exposure managers:

```python
class CustomExposureManager(ExposureManager):
    """Custom exposure manager example"""

    def __init__(self, param1, param2):
        self.param1 = param1
        self.param2 = param2

    def __call__(self, prices):
        # Custom multiplier calculation
        # Must return pd.Series with same index as prices

        price_series = prices['Close']
        volatility = prices['Volatility']

        # Example: Combine price and volatility
        multiplier = self.param1 / (price_series * volatility)

        return multiplier.fillna(0)

# Use it
exp_mgr = CustomExposureManager(param1=1000000, param2=0.5)
backtester = Backtester(strategy, exposure_manager=exp_mgr)
```

### 7.8 Exposure in Backtester Flow

The backtester applies exposure management as follows:

```python
def __call__(self, symbol, start_date, end_date, slippage_bps=0):
    # 1. Run strategy → get Position_At_Close
    self.strategy(symbol, start_date, end_date)
    df = self.strategy.df

    # 2. Calculate exposure multiplier (at close of each day)
    df['Exposure_Mult'] = self.exposure_manager(df)

    # 3. Calculate target shares (what we want at close)
    df['Shares_Target'] = df['Position_At_Close'] * df['Exposure_Mult']

    # 4. Calculate shares held at open (lagged from prior close)
    df['Shares_Held_At_Open'] = df['Shares_Target'].shift(1).fillna(0)

    # 5. Calculate PnL (using shares held during the day)
    df['Unslipped_PnL'] = df['Shares_Held_At_Open'] * df['Price_Change']

    # 6. Calculate slippage (from position changes)
    # Includes both entries/exits AND exposure adjustments
    ...
```

**Key Points:**
- Exposure multiplier calculated at close of each day
- Multiplier from day T applies to position held during day T+1
- Intraday exposure changes (multiplier updates) create slippage
- Modifiers can affect timing, but exposure is always at close

---

## 8. Backtester Layer

### 8.1 PnL Calculation Pseudocode

```python
def calculate_daily_pnl(df, slippage_bps):
    """
    Calculate daily PnL using df column names.

    Key principle: All PnL measured at close of each day.
    Shares held during the day determine PnL.
    """

    # === SETUP ===
    # Default: measure close-to-close price changes
    df['Price_Change'] = df['Close'].diff()

    # Detect signal days and entry/exit events
    df['Is_Signal_Day'] = df['Target_Position'].notna()

    position_at_prior_close = df['Position_At_Close'].shift(1).fillna(0)
    df['Is_Entry'] = (df['Position_At_Close'] > 0) & (position_at_prior_close == 0)
    df['Is_Exit'] = (df['Position_At_Close'] == 0) & (position_at_prior_close > 0)


    # === ADJUST PRICE_CHANGE FOR ENTRY TIMING ===
    for idx in df.index[df['Is_Entry']]:
        idx_loc = df.index.get_loc(idx)
        if idx_loc > 0:
            prev_idx = df.index[idx_loc - 1]

            if df.loc[prev_idx, 'Entry_Time'] == 'next_open':
                # Entry at open: measure Open[today] to Close[today]
                df.loc[idx, 'Price_Change'] = df.loc[idx, 'Close'] - df.loc[idx, 'Open']

            elif df.loc[prev_idx, 'Entry_Time'] == 'next_close':
                # Entry at close: no PnL on entry day
                df.loc[idx, 'Price_Change'] = 0


    # === ADJUST FOR EXIT TIMING ===
    for idx in df.index[df['Is_Exit']]:
        if df.loc[idx, 'Exit_Time'] == 'next_open':
            # Exit at next day's open: extend position holding
            idx_loc = df.index.get_loc(idx)
            if idx_loc > 0:
                prev_idx = df.index[idx_loc - 1]
                df.loc[idx, 'Price_Change'] = df.loc[idx, 'Open'] - df.loc[prev_idx, 'Close']
                # Hold shares from yesterday until open
                df.loc[idx, 'Shares_Held_At_Open'] = df.loc[prev_idx, 'Shares_At_Close']


    # === CALCULATE UNSLIPPED PNL ===
    df['Unslipped_PnL'] = df['Shares_Held_At_Open'] * df['Price_Change']


    # === CALCULATE SLIPPAGE ===
    df['Slippage'] = 0.0

    for idx in df.index:
        idx_loc = df.index.get_loc(idx)
        if idx_loc == 0:
            continue

        prev_idx = df.index[idx_loc - 1]
        shares_at_prior_close = df.loc[prev_idx, 'Shares_At_Close']
        shares_at_current_close = df.loc[idx, 'Shares_At_Close']

        if df.loc[idx, 'Is_Entry']:
            # Check if entry was signaled yesterday with next_open
            if df.loc[prev_idx, 'Entry_Time'] == 'next_open':
                # Trade 1: Entry at open (using prior close's multiplier)
                entry_shares = df.loc[idx, 'Shares_Held_At_Open']
                entry_price = df.loc[idx, 'Open']
                slippage_entry = abs(entry_shares) * entry_price * (slippage_bps / 10000)

                # Trade 2: Exposure adjustment at close (if multiplier changed)
                adjustment = shares_at_current_close - entry_shares
                if abs(adjustment) > 1e-6:
                    slippage_adj = abs(adjustment) * df.loc[idx, 'Close'] * (slippage_bps / 10000)
                else:
                    slippage_adj = 0

                df.loc[idx, 'Slippage'] = slippage_entry + slippage_adj

            else:
                # Entry at close: single trade
                shares_change = shares_at_current_close - shares_at_prior_close
                df.loc[idx, 'Slippage'] = abs(shares_change) * df.loc[idx, 'Close'] * (slippage_bps / 10000)

        elif df.loc[idx, 'Is_Exit']:
            # Exit trade
            if df.loc[idx, 'Exit_Time'] == 'next_open':
                exit_price = df.loc[idx, 'Open']
            else:
                exit_price = df.loc[idx, 'Close']

            df.loc[idx, 'Slippage'] = abs(shares_at_prior_close) * exit_price * (slippage_bps / 10000)

        else:
            # No entry/exit, but check for exposure adjustment
            shares_change = shares_at_current_close - shares_at_prior_close
            if abs(shares_change) > 1e-6:
                # Intraday rebalance due to multiplier change
                df.loc[idx, 'Slippage'] = abs(shares_change) * df.loc[idx, 'Close'] * (slippage_bps / 10000)


    # === CALCULATE SLIPPED PNL ===
    df['Slipped_PnL'] = df['Unslipped_PnL'] - df['Slippage']

    return df
```

### 8.2 Critical Edge Cases

#### Case 1: Entry at Next Open with Multiplier Change

**Scenario:**
```
Day T close:   Signal=1, Position_At_Close=0, Exp_Mult=2.0
               Entry_Time='next_open', Entry_Price=Open[T+1]
Day T+1 open:  Enter position
Day T+1 close: Exp_Mult=2.2 (updated)
```

**Behavior:**
- Shares entered at open = Target_Position × Exp_Mult[T] = 1 × 2.0 = 2.0
- Shares at close = Target_Position × Exp_Mult[T+1] = 1 × 2.2 = 2.2
- PnL for T+1 = 2.0 × (Close[T+1] - Open[T+1])
- Slippage:
  - Trade 1 (open): 2.0 shares at Open[T+1]
  - Trade 2 (close): 0.2 shares at Close[T+1] (exposure adjustment)

#### Case 2: Exit with Multiplier Change

**Scenario:**
```
Day T-1: Position_At_Close=1, Exp_Mult=2.0
Day T:   Position_At_Close=0 (exit signal), Exp_Mult=2.2
```

**Behavior:**
- Shares held on T = Shares_At_Close[T-1] = 2.0
- PnL = 2.0 × (Close[T] - Close[T-1])
- Slippage = 2.0 × Close[T] × (slippage_bps / 10000)
- New multiplier (2.2) is irrelevant since position goes to 0

#### Case 3: Exit at Next Open

**Scenario:**
```
Day T: Exit signal, Exit_Time='next_open'
Day T+1 open: Exit executed
```

**Behavior:**
- Extend position holding to T+1 open
- Shares held on T+1 = Shares_At_Close[T-1]
- Price_Change[T+1] = Open[T+1] - Close[T]
- Slippage = Shares_At_Close[T-1] × Open[T+1] × (slippage_bps / 10000)

---

## 9. Usage Examples

### 9.1 Basic Strategy

```python
from strategies import DMA
from libs.backtester import Backtester
from libs.exposure_management import VolatilityTargetExposure

# Create strategy
strategy = DMA(lookback=50, K=2)

# Create exposure manager
exp_mgr = VolatilityTargetExposure(total_dollar_size=100000)

# Backtest
backtester = Backtester(strategy, exposure_manager=exp_mgr)
backtester('AAPL', '2024-01-01', '2024-12-31', slippage_bps=5)

print(backtester.slipped_performance)
```

### 9.2 With Single Modifier

```python
# Entry at next open
strategy = DMA(lookback=50, K=2).enter_at_next_open()

backtester = Backtester(strategy, exposure_manager=exp_mgr)
backtester('AAPL', '2024-01-01', '2024-12-31', slippage_bps=5)
```

### 9.3 With Multiple Modifiers (Chained)

```python
# Fluent API
strategy = (DMA(lookback=50, K=2)
    .enter_at_next_open()
    .exit_at_next_open()
    .scale_position(0.5)
    .with_stop_loss(pct=2.0)
    .only_on_days(['Monday', 'Wednesday']))

backtester = Backtester(strategy, exposure_manager=exp_mgr)
backtester('AAPL', '2024-01-01', '2024-12-31', slippage_bps=5)
```

### 9.4 Comparing Strategies

```python
# Test different entry timings
strategies = {
    'Enter at Close': DMA(lookback=50, K=2),
    'Enter at Next Open': DMA(lookback=50, K=2).enter_at_next_open(),
    'Enter at Next Close': DMA(lookback=50, K=2).enter_at_next_close(),
}

results = {}
for name, strategy in strategies.items():
    bt = Backtester(strategy, exposure_manager=exp_mgr)
    bt('AAPL', '2024-01-01', '2024-12-31', slippage_bps=5)
    results[name] = bt.slipped_performance

# Compare
import pandas as pd
comparison = pd.DataFrame(results).T
print(comparison[['sharpe', 'total_pnl', 'num_trades']])
```

---

## 10. Extension Points

### 10.1 Custom Modifiers

Users can create custom modifiers:

```python
class MyCustomModifier(StrategyModifier):
    """Custom modifier example"""

    def __init__(self, strategy, param1, param2):
        super().__init__(strategy)
        self.param1 = param1
        self.param2 = param2

    def transform(self, df):
        # Custom logic
        # Modify df in-place
        # Set df.attrs if needed
        pass
```

### 10.2 Future Modifier Ideas

- `EnterAtTWAP`: Time-weighted average price execution
- `WithTrailingStop`: Dynamic stop-loss that trails price
- `WithProfitTarget`: Take profit at X% gain
- `ScaleInOut`: Gradually build/unwind positions
- `OnlyWhenVolatilityBelow`: Filter by volatility regime
- `WithMaxDrawdown`: Cut exposure after drawdown threshold
- `RebalancePeriodically`: Force rebalance on schedule
- `WithMinHoldingPeriod`: Prevent rapid entry/exit

---

## 11. Benefits Summary

### 11.1 Code Quality
- **Modularity**: Each modifier is 20-30 lines vs 100+ in backtester
- **Testability**: Test modifiers in isolation
- **Readability**: Clear column names eliminate ambiguity
- **Maintainability**: Changes localized to specific modifiers

### 11.2 Extensibility
- **Open/Closed Principle**: Add modifiers without changing backtester
- **Composability**: Chain modifiers in any order
- **Reusability**: Use modifiers with any strategy

### 11.3 User Experience
- **Fluent API**: `strategy.enter_at_next_open().with_stop_loss(2.0)`
- **Explicit**: Column names make behavior obvious
- **Flexible**: Mix and match modifiers for complex behaviors

### 11.4 Correctness
- **Explicit timing**: No guessing when trades occur
- **Accurate PnL**: Handles all edge cases (multiplier changes, etc.)
- **Transparent slippage**: Tracks all trades (entries, exits, adjustments)

---

## 12. Architecture Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                     Trading Strategy                         │
│                                                              │
│  ┌────────────┐      ┌──────────────┐    ┌──────────────┐  │
│  │   Prices   │─────→│   Strategy   │───→│   Modifiers  │  │
│  │  (OHLCV)   │      │              │    │              │  │
│  └────────────┘      │ - Signals    │    │ - Timing     │  │
│                      │ - Positions  │    │ - Sizing     │  │
│                      └──────────────┘    │ - Filters    │  │
│                                          │ - Risk Mgmt  │  │
│                                          └──────┬───────┘  │
│                                                 │          │
│                                                 ↓          │
│                                          ┌──────────────┐  │
│                                          │  Backtester  │  │
│                                          │              │  │
│                                          │ - Exposure   │  │
│                                          │ - PnL Calc   │  │
│                                          │ - Slippage   │  │
│                                          └──────┬───────┘  │
│                                                 │          │
│                                                 ↓          │
│                                          ┌──────────────┐  │
│                                          │ Performance  │  │
│                                          │   Results    │  │
│                                          └──────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

---

## 13. Conclusion

This modifier architecture provides a clean, extensible foundation for strategy backtesting. By separating strategy logic, execution modifiers, and backtester infrastructure, the design enables:

1. **Easy experimentation**: Test different execution timings, risk rules, etc.
2. **Composable complexity**: Build sophisticated strategies from simple modifiers
3. **Maintainable codebase**: Each component has clear responsibilities
4. **Accurate simulation**: Handles edge cases and timing nuances correctly

The pattern is similar to middleware in web frameworks, decorators in Python, and the Chain of Responsibility pattern in design patterns literature.
