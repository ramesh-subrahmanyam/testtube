"""
Performance Analytics Module

This module provides functions to calculate performance statistics
for trading strategies.
"""

import pandas as pd
import numpy as np


# Constants
TRADING_DAYS_PER_YEAR = 252


def stats(pnl_series, positions=None):
    """
    Calculate comprehensive performance statistics from a P&L series.

    Args:
        pnl_series (pd.Series): Series of daily profit and loss values
                               Index should be dates, values should be daily PnL
        positions (pd.Series, optional): Position series to identify trades

    Returns:
        dict: Dictionary containing:
            - sharpe: Annualized Sharpe ratio (all days)
            - sharpe_exposure: Annualized Sharpe ratio (exposure days only)
            - total_pnl: Total profit/loss
            - num_exposure_days: Total number of days with non-zero position
            - pnl_per_exposure_day: Average PnL per day of exposure
            - num_trades: Number of trades (round trips)
            - mean_pnl_per_trade: Average PnL per trade
            - num_wins: Number of winning trades
            - num_losses: Number of losing trades
            - avg_pnl_win: Average PnL per winning trade
            - avg_pnl_loss: Average PnL per losing trade
            - days_held_wins: Average days held for winning trades
            - days_held_losses: Average days held for losing trades
            - max_drawdown: Maximum drawdown (dollar amount)
            - drawdown_2: Second largest drawdown
            - drawdown_3: Third largest drawdown

    Example:
        # Assuming you have a strategy result with positions
        pnl = calculate_pnl(df['Close'], df['Position'])
        performance = stats(pnl, df['Position'])
        print(f"Sharpe: {performance['sharpe']:.2f}")
        print(f"Total PnL: ${performance['total_pnl']:.2f}")
    """
    if pnl_series is None or len(pnl_series) == 0:
        return {
            'sharpe': 0.0,
            'sharpe_exposure': 0.0,
            'total_pnl': 0.0,
            'num_exposure_days': 0,
            'pnl_per_exposure_day': 0.0,
            'num_trades': 0,
            'mean_pnl_per_trade': 0.0,
            'num_wins': 0,
            'num_losses': 0,
            'avg_pnl_win': 0.0,
            'avg_pnl_loss': 0.0,
            'days_held_wins': 0.0,
            'days_held_losses': 0.0,
            'max_drawdown': 0.0,
            'drawdown_2': 0.0,
            'drawdown_3': 0.0
        }

    # Total PnL
    total_pnl = pnl_series.sum()

    # Sharpe ratio (annualized) - using all days
    mean_pnl = pnl_series.mean()
    std_pnl = pnl_series.std()

    if std_pnl == 0 or np.isnan(std_pnl):
        sharpe = 0.0
    else:
        sharpe = (mean_pnl / std_pnl) * np.sqrt(TRADING_DAYS_PER_YEAR)

    # Calculate number of exposure days and exposure-only Sharpe
    # IMPORTANT: PnL is generated by LAGGED positions (position on day T generates PnL on day T+1)
    # So we must use lagged positions to align with the PnL calculation
    if positions is not None:
        # Lag positions by 1 to match PnL generation timing
        lagged_positions = positions.shift(1).fillna(0)
        num_exposure_days = (lagged_positions != 0).sum()

        # Calculate Sharpe ratio using only days where we had exposure (lagged position != 0)
        # This ensures we're measuring PnL on days that actually generated returns
        exposure_mask = lagged_positions != 0
        if exposure_mask.any():
            pnl_exposure_only = pnl_series[exposure_mask]
            mean_pnl_exposure = pnl_exposure_only.mean()
            std_pnl_exposure = pnl_exposure_only.std()

            if std_pnl_exposure == 0 or np.isnan(std_pnl_exposure):
                sharpe_exposure = 0.0
            else:
                sharpe_exposure = (mean_pnl_exposure / std_pnl_exposure) * np.sqrt(TRADING_DAYS_PER_YEAR)
        else:
            sharpe_exposure = 0.0
    else:
        num_exposure_days = 0
        sharpe_exposure = 0.0

    # Calculate PnL per exposure day
    if num_exposure_days > 0:
        pnl_per_exposure_day = total_pnl / num_exposure_days
    else:
        pnl_per_exposure_day = 0.0

    # Calculate trade-level statistics if positions are provided
    if positions is not None:
        trade_stats = _calculate_trade_stats(pnl_series, positions)
    else:
        # Fallback to simple calculation
        num_trades = (pnl_series != 0).sum()
        mean_pnl_per_trade = total_pnl / num_trades if num_trades > 0 else 0.0
        trade_stats = {
            'num_trades': num_trades,
            'mean_pnl_per_trade': mean_pnl_per_trade,
            'num_wins': 0,
            'num_losses': 0,
            'avg_pnl_win': 0.0,
            'avg_pnl_loss': 0.0,
            'days_held_wins': 0.0,
            'days_held_losses': 0.0
        }

    # Calculate drawdowns
    drawdown_stats = _calculate_drawdowns(pnl_series)

    return {
        'sharpe': sharpe,
        'sharpe_exposure': sharpe_exposure,
        'total_pnl': total_pnl,
        'num_exposure_days': num_exposure_days,
        'pnl_per_exposure_day': pnl_per_exposure_day,
        **trade_stats,
        **drawdown_stats
    }


def extract_trades(df, positions_col='Position', price_col='Close', pnl_col='Slipped_PnL', use_open_for_entry=False, use_open_for_exit=False):
    """
    Extract individual trade details from a strategy dataframe.

    Args:
        df (pd.DataFrame): Strategy dataframe with positions, prices, and PnL
        positions_col (str): Name of position column (default: 'Position')
        price_col (str): Name of price column (default: 'Close')
        pnl_col (str): Name of PnL column (default: 'Slipped_PnL')
        use_open_for_entry (bool): Use Open price for entry instead of Close (default: False)
        use_open_for_exit (bool): Use Open price for exit instead of Close (default: False)

    Returns:
        pd.DataFrame: DataFrame with one row per trade containing:
            - entry_date: Date of trade entry
            - entry_price: Price at entry
            - exit_date: Date of trade exit
            - exit_price: Price at exit
            - pnl: Total PnL for the trade
            - days_held: Number of days the trade was held
    """
    trades = []

    positions = df[positions_col]
    prices = df[price_col]
    pnl_series = df[pnl_col]

    # Find entries and exits
    entries = (positions != 0) & (positions.shift(1).fillna(0) == 0)
    exits = (positions == 0) & (positions.shift(1).fillna(0) != 0)

    # Track current trade
    in_trade = False
    entry_date = None
    entry_price = None
    trade_pnl = 0.0

    for idx in df.index:
        if entries.loc[idx] and not in_trade:
            # Start new trade
            in_trade = True
            entry_date = idx
            # Use Open price for entry if requested, otherwise use Close
            if use_open_for_entry and 'Open' in df.columns:
                entry_price = df.loc[idx, 'Open']
            else:
                entry_price = prices.loc[idx]
            trade_pnl = 0.0

        if in_trade:
            # Accumulate PnL
            trade_pnl += pnl_series.loc[idx]

        if exits.loc[idx] and in_trade:
            # Close trade
            exit_date = idx
            # Use Open price for exit if requested (next day's open), otherwise use Close
            if use_open_for_exit and 'Open' in df.columns:
                # Exit happens at next day's open, so look ahead
                idx_loc = df.index.get_loc(idx)
                if idx_loc + 1 < len(df):
                    next_idx = df.index[idx_loc + 1]
                    exit_price = df.loc[next_idx, 'Open']
                    exit_date = next_idx
                    # Also accumulate the PnL from the exit execution day
                    trade_pnl += pnl_series.loc[next_idx]
                else:
                    # Last day, use Close
                    exit_price = prices.loc[idx]
            else:
                exit_price = prices.loc[idx]
            days_held = (exit_date - entry_date).days

            trades.append({
                'entry_date': entry_date,
                'entry_price': entry_price,
                'exit_date': exit_date,
                'exit_price': exit_price,
                'pnl': trade_pnl,
                'days_held': days_held
            })

            in_trade = False
            entry_date = None
            entry_price = None
            trade_pnl = 0.0

    # Handle case where we're still in a trade at the end
    if in_trade and entry_date is not None:
        exit_date = df.index[-1]
        exit_price = prices.iloc[-1]
        days_held = (exit_date - entry_date).days

        trades.append({
            'entry_date': entry_date,
            'entry_price': entry_price,
            'exit_date': exit_date,
            'exit_price': exit_price,
            'pnl': trade_pnl,
            'days_held': days_held
        })

    return pd.DataFrame(trades)


def _calculate_trade_stats(pnl_series, positions):
    """
    Calculate trade-level statistics.

    A trade is defined as a period from entry to exit (position goes from 0 to non-zero to 0).

    Args:
        pnl_series (pd.Series): Daily PnL series
        positions (pd.Series): Position series

    Returns:
        dict: Trade-level statistics
    """
    # Identify trade periods (when position is non-zero)
    position_changes = positions.diff()

    # Find entries and exits
    entries = (positions != 0) & (positions.shift(1) == 0)
    exits = (positions == 0) & (positions.shift(1) != 0)

    # Identify trade groups
    in_trade = positions != 0
    trade_groups = (entries.cumsum())

    # Only consider periods when in trade
    trade_groups = trade_groups[in_trade]
    trade_pnl = pnl_series[in_trade]

    if len(trade_groups) == 0 or trade_groups.max() == 0:
        return {
            'num_trades': 0,
            'mean_pnl_per_trade': 0.0,
            'num_wins': 0,
            'num_losses': 0,
            'avg_pnl_win': 0.0,
            'avg_pnl_loss': 0.0,
            'days_held_wins': 0.0,
            'days_held_losses': 0.0
        }

    # Calculate PnL per trade
    trade_pnls = trade_pnl.groupby(trade_groups).sum()
    trade_days = trade_pnl.groupby(trade_groups).count()

    # Separate wins and losses
    # Note: Zero PnL trades are counted as wins
    winning_trades = trade_pnls[trade_pnls >= 0]
    losing_trades = trade_pnls[trade_pnls < 0]

    num_wins = len(winning_trades)
    num_losses = len(losing_trades)
    num_trades = len(trade_pnls)

    # Calculate averages
    avg_pnl_win = winning_trades.mean() if num_wins > 0 else 0.0
    avg_pnl_loss = losing_trades.mean() if num_losses > 0 else 0.0
    mean_pnl_per_trade = trade_pnls.mean() if num_trades > 0 else 0.0

    # Calculate days held (use >= 0 to match win/loss definitions)
    days_held_wins = trade_days[trade_pnls >= 0].mean() if num_wins > 0 else 0.0
    days_held_losses = trade_days[trade_pnls < 0].mean() if num_losses > 0 else 0.0

    return {
        'num_trades': num_trades,
        'mean_pnl_per_trade': mean_pnl_per_trade,
        'num_wins': num_wins,
        'num_losses': num_losses,
        'avg_pnl_win': avg_pnl_win,
        'avg_pnl_loss': avg_pnl_loss,
        'days_held_wins': days_held_wins,
        'days_held_losses': days_held_losses
    }


def _calculate_drawdowns(pnl_series):
    """
    Calculate the top 3 drawdowns.

    Args:
        pnl_series (pd.Series): Daily PnL series

    Returns:
        dict: Drawdown statistics
    """
    # Cumulative PnL
    cum_pnl = pnl_series.cumsum()

    # Running maximum
    running_max = cum_pnl.cummax()

    # Drawdown series
    drawdown = cum_pnl - running_max

    # Find all drawdown periods
    # A drawdown period starts when drawdown becomes negative and ends when it returns to 0
    in_drawdown = drawdown < 0

    if not in_drawdown.any():
        return {
            'max_drawdown': 0.0,
            'drawdown_2': 0.0,
            'drawdown_3': 0.0
        }

    # Group consecutive drawdown periods
    drawdown_groups = (in_drawdown != in_drawdown.shift()).cumsum()
    drawdown_groups = drawdown_groups[in_drawdown]

    # Get minimum (most negative) drawdown for each period
    if len(drawdown_groups) == 0:
        return {
            'max_drawdown': 0.0,
            'drawdown_2': 0.0,
            'drawdown_3': 0.0
        }

    drawdown_mins = drawdown[in_drawdown].groupby(drawdown_groups).min()

    # Sort to get top 3
    top_drawdowns = drawdown_mins.sort_values()

    max_dd = top_drawdowns.iloc[0] if len(top_drawdowns) > 0 else 0.0
    dd_2 = top_drawdowns.iloc[1] if len(top_drawdowns) > 1 else 0.0
    dd_3 = top_drawdowns.iloc[2] if len(top_drawdowns) > 2 else 0.0

    return {
        'max_drawdown': max_dd,
        'drawdown_2': dd_2,
        'drawdown_3': dd_3
    }


def calculate_pnl(prices, positions, initial_capital=100000):
    """
    Calculate daily P&L from prices and positions.

    Args:
        prices (pd.Series): Series of prices (Close prices)
        positions (pd.Series): Series of positions (1=long, 0=flat, -1=short)
        initial_capital (float): Initial capital (default: 100,000)

    Returns:
        pd.Series: Daily P&L series

    Note:
        This is a simplified P&L calculation. For more accurate results,
        you'd want to account for:
        - Transaction costs
        - Slippage
        - Position sizing
        - Margin requirements (for shorts)
    """
    # Calculate returns
    returns = prices.pct_change()

    # Lag positions by 1 day (trade on today's close, realize PnL tomorrow)
    lagged_positions = positions.shift(1).fillna(0)

    # Strategy returns = position * market returns
    strategy_returns = lagged_positions * returns

    # Dollar PnL
    pnl = strategy_returns * initial_capital

    return pnl


def extended_stats(pnl_series, prices=None, positions=None):
    """
    Calculate extended performance statistics.

    Args:
        pnl_series (pd.Series): Daily P&L series
        prices (pd.Series, optional): Price series for additional metrics
        positions (pd.Series, optional): Position series for additional metrics

    Returns:
        dict: Extended statistics including:
            - Basic stats (sharpe, total_pnl, num_trades, mean_pnl_per_trade)
            - max_drawdown: Maximum drawdown percentage
            - max_drawdown_duration: Maximum drawdown duration in days
            - win_rate: Percentage of profitable trades
            - profit_factor: Ratio of gross profits to gross losses
            - avg_win: Average winning trade
            - avg_loss: Average losing trade
            - largest_win: Largest winning trade
            - largest_loss: Largest losing trade
    """
    # Get basic stats
    basic = stats(pnl_series)

    # Extended stats
    extended = {}

    # Cumulative PnL for drawdown calculation
    cum_pnl = pnl_series.cumsum()

    # Maximum drawdown
    running_max = cum_pnl.cummax()
    drawdown = cum_pnl - running_max
    max_drawdown = drawdown.min()

    # Maximum drawdown as percentage of running max
    if running_max.max() > 0:
        max_drawdown_pct = (max_drawdown / running_max.max()) * 100
    else:
        max_drawdown_pct = 0.0

    extended['max_drawdown'] = max_drawdown
    extended['max_drawdown_pct'] = max_drawdown_pct

    # Maximum drawdown duration
    # Find periods where we're in drawdown
    in_drawdown = drawdown < 0
    if in_drawdown.any():
        # Find the longest consecutive True sequence
        groups = (in_drawdown != in_drawdown.shift()).cumsum()
        drawdown_lengths = in_drawdown.groupby(groups).sum()
        max_dd_duration = drawdown_lengths.max() if len(drawdown_lengths) > 0 else 0
    else:
        max_dd_duration = 0

    extended['max_drawdown_duration'] = int(max_dd_duration)

    # Win/Loss statistics (only for non-zero PnL days)
    non_zero_pnl = pnl_series[pnl_series != 0]

    if len(non_zero_pnl) > 0:
        wins = non_zero_pnl[non_zero_pnl > 0]
        losses = non_zero_pnl[non_zero_pnl < 0]

        # Win rate
        win_rate = (len(wins) / len(non_zero_pnl)) * 100 if len(non_zero_pnl) > 0 else 0.0
        extended['win_rate'] = win_rate

        # Profit factor
        gross_profit = wins.sum() if len(wins) > 0 else 0.0
        gross_loss = abs(losses.sum()) if len(losses) > 0 else 0.0

        if gross_loss > 0:
            profit_factor = gross_profit / gross_loss
        else:
            profit_factor = float('inf') if gross_profit > 0 else 0.0

        extended['profit_factor'] = profit_factor

        # Average win/loss
        extended['avg_win'] = wins.mean() if len(wins) > 0 else 0.0
        extended['avg_loss'] = losses.mean() if len(losses) > 0 else 0.0

        # Largest win/loss
        extended['largest_win'] = wins.max() if len(wins) > 0 else 0.0
        extended['largest_loss'] = losses.min() if len(losses) > 0 else 0.0

        # Number of wins/losses
        extended['num_wins'] = len(wins)
        extended['num_losses'] = len(losses)
    else:
        extended['win_rate'] = 0.0
        extended['profit_factor'] = 0.0
        extended['avg_win'] = 0.0
        extended['avg_loss'] = 0.0
        extended['largest_win'] = 0.0
        extended['largest_loss'] = 0.0
        extended['num_wins'] = 0
        extended['num_losses'] = 0

    # Combine basic and extended stats
    return {**basic, **extended}


def summary_table(stats_dict):
    """
    Create a formatted summary table of statistics.

    Args:
        stats_dict (dict): Dictionary of statistics (from stats() or extended_stats())

    Returns:
        str: Formatted string table
    """
    lines = []
    lines.append("=" * 60)
    lines.append("PERFORMANCE SUMMARY")
    lines.append("=" * 60)

    # Basic stats
    lines.append(f"Total P&L:              ${stats_dict.get('total_pnl', 0):,.2f}")
    lines.append(f"Sharpe Ratio:           {stats_dict.get('sharpe', 0):.3f}")
    lines.append(f"Number of Trades:       {stats_dict.get('num_trades', 0):,}")
    lines.append(f"Mean P&L per Trade:     ${stats_dict.get('mean_pnl_per_trade', 0):,.2f}")

    # Extended stats if available
    if 'max_drawdown' in stats_dict:
        lines.append("")
        lines.append("Drawdown Metrics:")
        lines.append(f"  Max Drawdown:         ${stats_dict.get('max_drawdown', 0):,.2f}")
        lines.append(f"  Max Drawdown %:       {stats_dict.get('max_drawdown_pct', 0):.2f}%")
        lines.append(f"  Max DD Duration:      {stats_dict.get('max_drawdown_duration', 0)} days")

    if 'win_rate' in stats_dict:
        lines.append("")
        lines.append("Win/Loss Metrics:")
        lines.append(f"  Win Rate:             {stats_dict.get('win_rate', 0):.2f}%")
        lines.append(f"  Profit Factor:        {stats_dict.get('profit_factor', 0):.3f}")
        lines.append(f"  Number of Wins:       {stats_dict.get('num_wins', 0)}")
        lines.append(f"  Number of Losses:     {stats_dict.get('num_losses', 0)}")
        lines.append(f"  Average Win:          ${stats_dict.get('avg_win', 0):,.2f}")
        lines.append(f"  Average Loss:         ${stats_dict.get('avg_loss', 0):,.2f}")
        lines.append(f"  Largest Win:          ${stats_dict.get('largest_win', 0):,.2f}")
        lines.append(f"  Largest Loss:         ${stats_dict.get('largest_loss', 0):,.2f}")

    lines.append("=" * 60)

    return "\n".join(lines)


if __name__ == "__main__":
    # Example usage
    print("=" * 80)
    print("Performance Analytics Examples")
    print("=" * 80)

    # Create sample data
    np.random.seed(42)
    dates = pd.date_range('2024-01-01', '2024-12-31', freq='D')

    # Simulate a strategy with positive drift and volatility
    daily_returns = np.random.normal(0.001, 0.02, len(dates))
    prices = pd.Series(100 * np.exp(np.cumsum(daily_returns)), index=dates)

    # Simple strategy: long when price > 20-day MA, flat otherwise
    ma_20 = prices.rolling(20).mean()
    positions = pd.Series(0, index=dates)
    positions[prices > ma_20] = 1

    # Calculate P&L
    pnl = calculate_pnl(prices, positions, initial_capital=100000)

    print("\nExample 1: Basic Statistics")
    print("-" * 80)
    basic_stats = stats(pnl)
    print(f"Sharpe Ratio: {basic_stats['sharpe']:.3f}")
    print(f"Total P&L: ${basic_stats['total_pnl']:,.2f}")
    print(f"Number of Trades: {basic_stats['num_trades']}")
    print(f"Mean P&L per Trade: ${basic_stats['mean_pnl_per_trade']:.2f}")

    print("\nExample 2: Extended Statistics")
    print("-" * 80)
    ext_stats = extended_stats(pnl, prices, positions)
    print(summary_table(ext_stats))

    print("\nExample 3: Comparing Strategies")
    print("-" * 80)

    # Strategy 2: Buy and hold
    positions_bh = pd.Series(1, index=dates)
    pnl_bh = calculate_pnl(prices, positions_bh, initial_capital=100000)
    stats_bh = stats(pnl_bh)

    print("MA Strategy:")
    print(f"  Sharpe: {basic_stats['sharpe']:.3f}, Total P&L: ${basic_stats['total_pnl']:,.2f}")

    print("\nBuy & Hold:")
    print(f"  Sharpe: {stats_bh['sharpe']:.3f}, Total P&L: ${stats_bh['total_pnl']:,.2f}")

    print("\n" + "=" * 80)
    print("Examples completed successfully!")
